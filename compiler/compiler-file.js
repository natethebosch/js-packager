/*
* @Author: Nate Bosscher (c) 2015
* @Date:   2016-09-05 07:53:25
* @Last Modified by:   Nate Bosscher
* @Last Modified time: 2016-09-05 10:41:32
*/

var objNameFromFileName = require("./obj-name-from-file-name");
var path = require("path");
var arrayContainsUniqueValues = require("./array-unique");

/**
 * File class
 *
 * file_spec = { file_name: "", file_contents: "" }
 * base_dir = "base directory for compilation"
 */
var File = function(file_spec, base_dir){
	var self = this;

	this.file_name = file_spec.file_name;
	this.rel_file_name = this.file_name.replace(base_dir, "");
	this.rel_dir_name = path.dirname(this.rel_file_name);
	this.file_contents = file_spec.file_contents;

	this.obj_name = objNameFromFileName(this.rel_file_name);

	this.requires = []; // a.b.c
	this.req_map = {}; // a.b.c => 'require("./a/b/c")'

	this.obj_map = null; // ObjMap

	this.setObjMap = function(obj){
		this.obj_map = obj;

		var reqrs = file_spec.file_contents.toString().match(/require\([^\)]+\)/g);
		if(!reqrs)
			return [];

		for(var i = 0; i < reqrs.length; i++){
			var n = reqrs[i].replace(/^require\(/, "").replace(/\)$/, "")
			n = n.replace(/(^['"]+|['"]+$)/g, "");

			var pth = path.resolve(this.rel_dir_name, n);

            var objPth = objNameFromFileName(pth);
			var req = this.obj_map.lookup(objPth);
			if(!req){

				// assume pth is a directory name. append fileName, resolve objname
				// and then remove fileName portion
				objPth = objNameFromFileName(pth + "/test.js");
				objPth = objPth.replace(/\.Test$/, "")

				req = this.obj_map.lookup(objPth);
				if(!req)
					throw "Couldn't resolve dependancy for '" + objNameFromFileName(pth) + "' or '" + objPth + "' (source = " + reqrs[i] + ")";
			}

			this.req_map[objPth] = reqrs[i];
			this.requires[i] = objPth;
		}

	};

	// obj => CompilerDir | CompilerFile
	this.dependsOn = function(obj){

//	    console.log(obj.obj_name, this.requires, this.obj_name);

		if(this.requires.indexOf(obj.obj_name) != -1){
			return true;
		}

		for(var i = 0; i < this.requires.length; i++){

		    var rq = this.obj_map.lookup(this.requires[i]);
			if(rq.obj_name == obj.obj_name || rq.dependsOn(obj)){
				return true;
			}
		}

		return false;
	};

	/**
	 * takes objP1.objP2.objP3
	 *
	 * returns [objP1.objP2, objP1]
	 */
	this.parentDirectories = function(){
		var dirs = [];

		var parts = this.obj_name.split(".");
		parts.pop();

		while(parts.length > 0){
			dirs.push(parts.join("."));
			parts.pop();
		}

		return dirs;
	};

	/**
	 * circular_spec => { max_depth: int, path: [obj.name], map: ObjMapManager }
	 * 
	 * @param  {[type]} circular_spec [description]
	 * @return {[type]}               [description]
	 */
	this.checkForCircularRefs = function(circular_spec){
		if(circular_spec.max_depth == 0)
			throw "Circular reference check failed to resolve (max-depth reached) for path " + circular_spec.path.join("\n\t-> ");

		for(var i = 0; i < this.requires.length; i++){
			circular_spec.path.push(this.requires[i]);

			if(!arrayContainsUniqueValues(circular_spec.path)){
				throw "Circular reference for path \n\t-> " + circular_spec.path.join("\n\t-> ");
			}

			var fileOrDir = circular_spec.map.lookup(this.requires[i]);

			if(!fileOrDir){
				throw "failed to load " + this.requires[i] + " (from " + this.req_map[this.requires[i]] + ") in file " + this.file_name + "";
            }

			fileOrDir.checkForCircularRefs({
				max_depth: circular_spec.max_depth -1,
				path: circular_spec.path,
				map: circular_spec.map
			});

			circular_spec.path.pop(); // remove sub-item from path 
		}
	};

	// map generated by getUniqueDependacyNameMap()
	this.getContentsWithRequiresReplaced = function(map){
		var out = this.file_contents;
		for(var i in map){
			var req = this.req_map[map[i]];

			while(out.indexOf(req) != -1)
				out = out.replace(req, i);
		}

		return out;
	};

	// returns obj_name_uid => obj_name
	this.getUniqueDependacyNameMap = function(){
		var map = {}; // obj_name_uid => obj_name
		for(var i = 0; i < this.requires.length; i++){
			var j = 0;
			var name = "";
			var foundUnique = false;
			while(!foundUnique){
				name = this.requires[i].replace(/\./g, "_") + "_uid_" + j;
				foundUnique = this.file_contents.indexOf(name) == -1;
				j++;
			}

			map[name] = this.requires[i];
		}

		return map;
	};
};

module.exports = File;